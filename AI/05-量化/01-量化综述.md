# 量化

来源：

https://zhuanlan.zhihu.com/p/132561405

https://zhuanlan.zhihu.com/p/64744154

## **Part 1 量化综述**

### **什么是模型量化？为什么要进行模型量化？**

模型量化是由模型、量化两个词组成。我们要准确理解模型量化，要看这两个词分别是什么意思。

在计算机视觉、深度学习的语境下，模型特指卷积神经网络，用于提取图像/视频视觉特征。

量化是指将信号的连续取值近似为有限多个离散值的过程。可理解成一种信息压缩的方法。在计算机系统上考虑这个概念，一般用“低比特”来表示。也有人称量化为“定点化”，但是严格来讲所表示的范围是缩小的。定点化特指scale为2的幂次的线性量化，是一种更加实用的量化方法。

![img](../imgs/v2-0eb942478b9beb5cafae957bff92b19e_1440w.png)

卷积神经网络具有很好的精度，甚至在一些任务上比如人脸识别、图像分类，已经超越了人类精度。但其缺点也比较明显，具有较大的参数量，计算量，以及内存占用。而模型量化可以缓解现有卷积神经网络参数量大、计算量大、内存占用多等问题，具有为神经网络压缩参数、提升速度、降低内存占用等“潜在”优势。为什么“潜在”是加引号的呢？因为想同时达到这三个特性并不容易，在实际应用过程中存在诸多限制和前提条件。

另外，由于模型量化是一种近似算法方法，精度损失是一个严峻的问题，大部分的研究都在关注这一问题。作为一个在公司支撑很多业务线的团队，我们会在关注精度的同时，注重部署最终的速度和资源占用情况。

### **压缩参数**

![img](../imgs/v2-52618ac0bf3518080b77f7fc49f7323e_1440w.webp)

模型量化在最初的定义里是为了压缩模型参数，比如韩松在ICLR2016上获得best paper的论文，首次提出了参数量化方法。其使用k-mean聚类，让相近的数值聚类到同一个聚类中心，复用同一个数值，从而达到用更少的数值表示更多的数，这是量化操作的一种方案。反过来，从量化数变到原始数的过程，称之为反量化，反量化操作完之后，模型就可以按照原来的方式进行正常的计算。

我们认为绝大部分的模型量化算法都能压缩参数，因此压缩参数的实用性不存在问题。

### **提升速度**

![img](../imgs/v2-2a4223b3022be115bb8b7e5ccca8acde_1440w.png)

量化是否一定能加速计算？回答是否定的，许多量化算法都无法带来实质性加速。

引入一个概念：理论计算峰值。在高性能计算领域，这概念一般被定义为：单位时钟周期内能完成的计算个数 乘上 芯片频率。

什么样的量化方法可以带来潜在、可落地的速度提升呢？我们总结需要满足两个条件：

1、量化数值的计算在部署硬件上的峰值性能更高 。

2、量化算法引入的额外计算（overhead）少 。

要准确理解上述条件，需要有一定的高性能计算基础知识，限于篇幅就不展开讨论了。现直接给出如下结论：已知提速概率较大的量化方法主要有如下三类，

1、**二值化**，其可以用简单的位运算来同时计算大量的数。对比从nvdia gpu到x86平台，1bit计算分别有5到128倍的理论性能提升。且其只会引入一个额外的量化操作，该操作可以享受到SIMD（单指令多数据流）的加速收益。

2、**线性量化**，又可细分为非对称，对称和ristretto几种。在nvdia gpu，x86和arm平台上，均支持8bit的计算，效率提升从1倍到16倍不等，其中tensor core甚至支持4bit计算，这也是非常有潜力的方向。由于线性量化引入的额外量化/反量化计算都是标准的向量操作，也可以使用SIMD进行加速，带来的额外计算耗时不大。

3、**对数量化**，一个比较特殊的量化方法。可以想象一下，两个同底的幂指数进行相乘，那么等价于其指数相加，降低了计算强度。同时加法也被转变为索引计算。但没有看到有在三大平台上实现对数量化的加速库，可能其实现的加速效果不明显。只有一些专用芯片上使用了对数量化。

![img](../imgs/v2-a4f481df63477b7af50dcf571d3121ad_1440w.png)

简单看一下二值化和线性量化两种方式，分别是右上角的图和右下角的图。

总结一下，要使用量化技术来提升模型运行速度，需要满足两个条件：

1、选择适合部署的量化方案。

2、在部署平台上使用经过深度优化的量化计算库（必要的时候，可能需要撸起袖子自己上）。

首先保证你实现的低比特计算效率超过原先浮点计算，否则为何要承担精度损失的风险而使用并不加速的量化模型呢。但低比特计算效率超过浮点计算其实并不容易，因为大家在浮点的计算库上已经做了非常多细致的优化比如winograd，间接卷积等等。

为了最大限度保证实用性，后面的论文所有工作都是基于二值化、线性量化两种前提来做的，并且绝大部分工作都报告最终实际的加速效果。这也是链接与编译团队做研究的一个风格。

### **降低内存**

![img](../imgs/v2-637b9153cfc3465aecc066343c98a02f_1440w.png)

模型量化还有一个潜在的好处是降低运行时内存占用，这个特性无论是在移动端还是云端都是具有现实意义的。如果降低内存占用，可以得到如下好处：

1、降低访存量，存在提升速度的可能 。

2、在同样硬件环境下，同时处理更多视频或者视频路数 。

3、训练更大的模型。

我们分析下运行时内存都是被什么东西占用的，大家关心的参数weight只占很少一部分， 大部分内存占用来自激活值activation。如果你做低比特量化只关注卷积的话（很多论文其实也是只量化了卷积），那么是无法带来内存占用降低的。

如何才能用量化降低内存占用，只有一个方式: 将尽可能多的layer的激活值都进行量化 。在这个方向上之前商汤的一位实习生李润东也有一个工作，做了除了卷积之外更多层的量化。但是这样做会带来更多的精度损失，这可能也是大家需要关心的。

### **生产量化模型**

![img](../imgs/v2-ff854c348a7fb09ac5c3424395c2fcfd_1440w.webp)

生产一个量化模型的有以下几种方法，借鉴了ICCV2019上一篇data-free量化论文的定义。

L1：直接将一个浮点参数直接转化成量化数，一般会带来很大的精度损失，但使用上非常简单。

L2：基于数据校准的方案，很多芯片都会提供这样的功能，比如tensorRT，高通，寒武纪等。它需要转模型的时候提供一些真实的计算数据。

L3：基于训练finetune的方案，有很多论文都是使用这种方法，它的好处是可以带来更大的精度提升，缺点是需要修改训练代码，实施周期比较长。

上图描述了一种实用的pipeline流程，一般会优先使用不进行finetune的offline方法，也就是离线方案。当离线方案精度损失过于严重，我们才会进行基于finetune的方法，来做进一步的抢救。

### **量化模型的落地**

![img](../imgs/v2-cc80dbe2114757d0d93d551d0d90cebf_1440w.png)



最后聊聊阻碍模型量化算法落地的几个问题，核心当然是精度问题。我们发现虽然学术界大家很早就开始做量化，但现在算法还无法大规模落地。主要存在几个Gap：

1、可落地的线性量化方案无法很好的刻画一些分布，比如高斯分布

2、比特数越低，精度损失就越大，实用性就越差

3、任务越难，精度损失越大，比如识别任务，就比分类任务要难非常多

4、小模型会比大模型更难量化

5、某些特定结构，如depthwise，对量化精度十分不友好

6、常见的对部署友好的方法比如merge BN，全量化，都会给精度带来更大的挑战

除了精度外，软硬件支持不好也是一个阻碍：不同的硬件支持的低比特指令是不一样的，同样训练得到的低比特模型，无法直接部署在所有硬件上。除了硬件之外，不同软件库实现的量化方案和细节也不一样，量化细节里包括量化位置、是否支持perchannel、是否混合精度等等。即使硬件支持了量化，但你会发现不是所有硬件可以在低比特上提供更好的速度提升， 造成这个状况的主要原因有多个，一方面是指令集峰值提升可能本身就并不多，而要引入较多的额外计算，另一方面也取决于软件工程师优化指令的水平，同时由于网络结构灵活多样，不一定能在不同网络结构上达到同样好的加速比，需要优化足够多的的corner case才可以解决。

相信大家对模型量化的概念和落地难点有了一个系统性的认识。我的部分就到这里结束了，下面是大家最期待的论文解读时间。

## **Part 2 论文解读**

### **低比特量化：**

**Differentiable Soft Quantization: Bridging Full-Precision and Low-Bit Neural Networks（ICCV 2019）**

论文地址：[https://arxiv.org/abs/1908.0503](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1908.05033)

由于量化函数本身是离散不可导的，导致其无法像标准神经网络一样使用反向传播计算梯度，一个常用的做法是使用梯度直通估计器（STE），即在反向过程中忽略量化这一步骤产生的影响，而这也就自然的带来了梯度不准确的问题。权重经过STE拿到的梯度跟它应该拿到的梯度是不匹配的。ICLR 2020年有一篇论文通过实验具体的分析了这一现象，发现随着比特数的降低，不匹配的现象更加明显。

![img](../imgs/v2-fbdae4a30f4dde7d9cf30d53ff469dab_1440w.png)

这让低比特量化网络很难高效训练，针对这个问题，该文章提出了一个可微分的软量化函数DSQ，引入了可求导的量化函数，缓解了不可求导带来的梯度不匹配问题。同时，这个函数随着训练的进行可以逐步趋近标准量化，因此可以在部署时直接利用高效的线性低比特量化函数进行推理，此外，由于这个函数是可以求导的，因此截断值也能够直接被优化，在训练过程中平衡截断误差和取整误差间的关系。

![img](../imgs/v2-b3c63079afd646d41340196f54da5518_1440w.png)

通过可视化分析，我们发现经过DSQ函数后，参数的分布更加接近于量化后的分布，减小了浮点参数和量化参数的鸿沟。为了验证这套方法的效率，我们基于ARM NEON中的SADDW和MLA指令实现了高效的低比特卷积，并在树莓派上以ResNet-18为基础进行测试，相比腾讯开源的高性能推理库NCNN有1.6倍左右的提速。

![img](../imgs/v2-e6b6355979ef3d41f04588b2da5d92b3_1440w.png)

### **模型二值化：**

**IR-Net: Forward and Backward Information Retention for Highly Accurate Binary Neural Networks（CVPR 2020）**

论文地址：[https://arxiv.org/abs/1909.10788](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1909.10788)

项目地址：[https://github.com/htqin/IR-Net](https://link.zhihu.com/?target=https%3A//github.com/htqin/IR-Net)

模型二值化在模型的激活值和参数上只有两个值（0和1）表示，可以预见的是这样量化肯定会带来较大的精度和信息损失。该文章引入了信息熵，以量化参数和浮点参数的信息熵作为模型的评判标准。

除了前向信息损失，二值化模型在反向过程中面临的挑战更大，标准的恒等映射梯度近似会导致较大的梯度误差，而包含截断建模的梯度近似会使得大量被截断的数值不能得到更新，损失了更新能力。该文章提出了两阶段近似梯度估计器，让模型优化在前期保持比较高的更新能力，后期梯度的误差更低。

![img](../imgs/v2-d981bc5845506a1154dc8b32948c24d6_1440w.png)

同样在树莓派上进行了速度验证，借助京东开源的daBNN推理库，测试了IR-Net的性能，相比daBNN中的全精度模型，大约有5.6倍左右的速度提升。

![img](../imgs/v2-502038ebc7dfcf06fad4448ec398195e_1440w.png)

### **8bit训练加速：**

**Towards Unified INT8 Training for Convolutional Neural Network（CVPR 2020）**

论文地址：[https://arxiv.org/abs/1912.1260](https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1912.12607)

除了使用量化技术加速前向推理过程，是否能够进一步加速包含反向传播在内的梯度计算过程呢？分析发现反向传播在训练过程中占用了一半的时间，如果能减少这个时间，那么就能大大增加训练效率。一个直接的想法就是量化梯度，但这样做会导致训练不收敛。经过统计，我们发现梯度的分布与激活值和参数值有很大不同，大量参数出现在0附近，同时存在较大的极端值，如果对其进行量化会带来非常大的量化误差。

![img](../imgs/v2-43e8dac6f50d6ab69aad56d537c4d260_1440w.png)

发现了梯度的特征后，我们从理论角度进行了分析，借鉴了优化理论中的后悔值分析。推导出了引入梯度量化之后的收敛性上界：

![img](../imgs/v2-9ae2793e19320cd7ad85e1b423354505_1440w.png)

该上界包含三项，其中第一项随更新迭代的进行会趋向于零，因此主要由后两项决定，分别对应量化误差的大小和学习率。只有确保该上界尽可能小，收敛性才能得到保证。

![img](../imgs/v2-9e10f19e93735b0546afa88759118500_1440w.png)

因此针对第二项和第三项，通过使量化梯度与实际梯度的cosine距离更加接近，降低量化误差，然后根据误差的大小减小学习率，使得尽可能在更加正确的方向上进行更新，并且不会在错误的方向上更新过多，可以保证在收敛边界内更新，确保正常收敛。论文在分类和目标检测任务上都进行了精度验证，损失在1%左右。

![img](../imgs/v2-67bebb844d36c59ef6d68276b82922fe_1440w.png)

借助高性能团队提供的初步优化实现，该方法可以在NVIDIA GTX 1080TI上带来22%的加速。

![img](../imgs/v2-01d91d84044bf843ed975609dfabff36_1440w.png)

### **低比特人脸识别：**

**Rotation Consistent Margin Loss for Efficient Low-bit Face Recognition（CVPR 2020）**

由于开集问题里测试集中存在训练集不存在的类别，因此识别任务比分类任务更难，评价指标也更加严格。而引入量化之后，也就面临着更大的挑战。为了深入分析人脸识别受量化的影响，论文首先基于人脸特征使用夹角度量作为相似度衡量的共识定义了量化误差，并定义量化后的类中心为属于该类所有样本特征进行量化后的均值。对量化误差进行分析，发现引入量化后每个类的中心都有所偏移，但类之间的夹角保持住了，类内的距离保持的较差。可以理解成各类在量化后产生了一个整体的旋转，每个类的紧凑性有所下降。

![img](../imgs/v2-fca2076448376b4d9a254eedf78a8025_1440w.png)

因此文章将量化误差分解成类偏差和个体偏差。文章提出了旋转一致损失函数，使得样本具有与类中心有同样的偏移，抵消量化带来的影响，让特征更加保序。

![img](../imgs/v2-acbbe3e4a23f0fd792be13f165efa376_1440w.png)

论文在不同数据集上进行了实验，在简单的数据集上3/4bit基本能够保持精度，在更有挑战的数据集上相比基线方法也能够有1-2%的精度提升。

![img](../imgs/v2-66d0c4c7043495d5ecb1b225f84a10c4_1440w.png)

### **量化友好网络结构：**

**DMS: Differentiable diMension Search for Binary Neural Networks（ICLR 2020 Workshop）**

论文地址：[https://drive.google.com/file/d/1DgD1mIBv7MHwM27Vjvb-g8IwlUOv6UJF/view?usp=sharing](https://link.zhihu.com/?target=https%3A//drive.google.com/file/d/1DgD1mIBv7MHwM27Vjvb-g8IwlUOv6UJF/view%3Fusp%3Dsharing)

项目地址：[https://github.com/yhhhli/DMS_for_BNN](https://link.zhihu.com/?target=https%3A//github.com/yhhhli/DMS_for_BNN)

对量化和网络结构的探索，许多论文都会对网络结构进行微调：增加通道数量，修改跨层连接等。对于二值化模型来说这些改动能带来比全精度模型更大的收益。

![img](../imgs/v2-273cc762325e6a8d02a112812de7cadc_1440w.png)

这启发了我们，是否存在一些模型结构，他们对于量化更加友好呢？本文从卷积核output channel的角度进行了探索，将量化背景下的channel探索转换为网络结构搜索（NAS）问题。Channel的搜索空间一般较大，直接使用已有的NAS会面临非常高的搜索复杂度，为了解决这个问题，本文提出了搜索空间聚类方法。首先将channel的变换参数r建模为服从Logistic分布的随机变量，广义的搜索空间可以认为是从该分布中进行采样，我们将采样限制为三个点：()，由于Logistic分布的分布函数可以进行求导，和能够进行优化，同时我们将进行衰减，即可最终收敛到上，作为最优的channel放缩系数。

对搜索空间进行建模，对网络结构进行探索。

![img](../imgs/v2-a6d55ddfd70681c1343b6a35476c53bd_1440w.png)

实验表明，搜索得到的结构具有较大的精度潜力，使用ResNet-18拓扑，通过寻找最优的channel设置，在参数量比标准BNN少的情况下，可以实现7%左右的精度提升。

![img](../imgs/v2-3a7db911a34c15d2d15006fb932d6670_1440w.png)

## **Part 3 Q&A**

**Q：主流训练框架是否支持finetune方法的INT8量化？**

A：finetune 方法的INT8量化在现在的tensorflow里是支持得比较好的，可以看到google的量化白皮书中就介绍了finetune。Pytorch正在补齐这方面的功能，在1.3版本中加入了finetune 的量化功能，但还在实验阶段。所以现在的PyTorch框架做的比较一般，但公司内部会提供完善的finetune方案和开源算法。

**Q：不同量化任务难度有差异的原因是什么？哪些任务作为INT8量化损失会比较大？**

A：例如分类任务，只要保证最终的预测概率的相对大小，是保持关系即可，但回归任务，比如检测任务偏一点都会影响到检测出框的准确性，所以会比分类任务的难度更高。刚才提到的人脸识别的任务是出feature的，feature的方向以及本身衡量的难度使其比分类任务更加困难，以及一些low level的任务因为输出的各个像素点都要顾及到，所以也会比分类任务更困难。另外从分布方面，量化需要做分布的考虑，如果一些任务对分布不友好，量化的部署也会更加困难。

**Q：在对网络结构友好型的量化过程中 对于channel分配上有什么经验？**

A：可以看到我们的论文补充材料中展示了最终的channel数，总结来看如果层中本身计算量较小，那么它的channel就需要更大一些，不同网络结构的规律也有所不同。

**Q：INT8 Training是从头开始训练的时候就采用8bit定点吗？还是说先全FP32精度进行训练一段时间，再进行量化？是仅对卷积层进行了8比特定点量化吗？**

A：从头开始训练的时候就采用8bit定点。第二种方法会更稳定一些，但无法达到较好的加速效果。当前我们的方案里只对卷积层进行量化，并且没有关心全连接层和第一层的卷积，这是一个比较标准的setting，所以目前达到的加速效果还没有很好，如何做得更快是需要其他层都需要量化的。

**Q：当模型在真正部署，需要模型压缩的时候，量化、剪枝、知识蒸馏等压缩方法一般会使用哪些呢？**

A：量化是一个大部分硬件平台都会支持的，因此比较常用；知识蒸馏有利于获得小模型，还可以进一步提升量化模型的精度，所以这个技巧也会使用，尤其是在有已经训好比较强的大模型的基础上会非常有用。剪枝用的会相对较少，因为可以被网络结构搜索覆盖。
